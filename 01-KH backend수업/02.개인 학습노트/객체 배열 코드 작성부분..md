1. 문제에서 제시된 요구사항을 잘 확인하고 어느것 부터 코드를 작성해야 할지 잘 찾기 .
2. 자주 사용하는 메소드가 있고 그 메소드가 특정 값을 반환하고 그 값이 실행마다 달라지지 않는다면 변수로 선언하여 최적화를 시키자.
3. 분기문의 각 for문 while문 if문에서의 사용 확인하기. 
   ㄴ 예제 코드에서 while 문에서는 continue 만날 시 조건식으로 되돌아감.
```java
Sysout("아이디");
String inputId = sc.nextLine();
//입력을 받고 처리를 해야함. 
//중복 아닐때까지 처리해야하니까 와일문에 감싸서 중복이 아닐때 하기. 
아이디 체크 후 반환값이 true면 사용가능 false면 사용 불가능.
boolean flag = mc.cheackId(inputId);
if(flag){
	break;//무한반복 탈출
}else{
	sysout("중복 아이디 다시 입력 : ")
	inputId = sc.nextLine();
}
// 내 생각과 코드 
//먼저 if문 안에서 사용자에게 다시 입력 받을 생각을 못하고 while문을 어떻게 작성해야 할지만 고민했었다.

```


```java
public boolean checkId(String inputId); 메소드 작성하기.
처리내용: 현재 등록된 회원 (m 배열)정보중 전달받은 아이디랑 일치하는 회원 확인하기.


for(인덱스 길이만큼)
if(해당 인덱스에 널이 아닐때만 회원조회)
if(전달 받은 아이디와 이미 등록된 회원 아이디가 같으면 return false 반환)


조건문 밖에서는 return true를 사용해서 등록 성공으로 넘어가게 만듦.


```
#### 자료구조 정렬의 필요성 =(코드의 간소화)
##### 정렬되지 않은 상태이기 때문에 반복문을 사용하여 객체배열중 빈공간에(null) 넣어주기.
메소드 insertMember(아이디 이름 비번 이메일 성별 나이){

View 단에서 전달 받아온 값으로 매개변수 생성자 이용해서 객체 생성
Member mem = new Member(id,name,pw,email,gender,age);
바로 객체 배열에 생성해서 넣어도 괜찮음.
**beak;** 까먹지 말기....  <-- 오류의 발생 원인.
//객체 배열에 넣고싶다.
#### 초기화 블록의 위치를 잘 넣자.

### print all()메서드
- 컨트롤러에서 객체배열 m 의 값을 반환하고.
- 뷰 (메뉴) 단에서 Member \[   \] m = mc.printAll();
- for문 사용하여 정렬되지 않아있는 데이터들이 있으니, m\[ i \]의 주소값이 Null이 아닌 경우에 inform( ) 메서드 사용하여 출력해주기. 
- 핵심: for문으로 정렬 안된 데이터니까 null로 비교하기.

### SearchMember()메서드
- 화면 출력(view단 ) 메소드 switch case문 사용하여 작성하기.
### SearchId()메서드
- 메뉴에서 받아온 애랑 회원이랑 일치하면 해당 하는 회원 배열m의 inform()메소드 반환 해라.
-  여기도 정렬 안되어있으니까 for으로 모든 회원 확인하기.
- 전체 배열 도는 부분, (for에) if 두개 (아이디 비교, 하나는 inform출력용)작성하기.
- 여기또한 break; 잘 작성해주기.

### searchName()메서드(view단)
- 사용자에게 변수 받아서 변수 하나 선언하고 배열타입에 넣어줘야 하니,
  멤버\[\] 변수명 = 멤버컨트롤러의 메소드 호출하여 배열타입으로 값 넘겨주기.
-- 메소드 만들고 나서...
- 널로 비교할 수 없음 :
  서치 객체 배열은 이미 생성된 채로 넘어오기 때문에 null로 비교하지 않음.
  대신 인덱스 위치에 들어있는 객체가 null인지를 비교한다.
	- if searched\[ 0 \] \=\= null이면(비어있으면  0번부터 비어있으면 아무것도 없겠지..)
	  없다고 sysout 없음 적기.
	
	- else 몇개나 남겨있을지 모르니 반복문으로 돌리면서 확인해주고. 
	  if searched\[i\] \=\=null {   //중간에 값이 Null이면 그 이후로는 없을거니까. 브레이크로 탈출해주기.
	  break; 
	  }
### searchName()메서드(controller 단 )
- 이름으로 호출하는 메서드 
- // 반환타입이 객체배열 타입임: 동명이인이 있을 수 있으니 해당 정보를 모두 호출하여 구분하려고.
- 검색된 회원들 정보를 담을 객체배열을 하나 준비하여 검색된 인원들을 담아주고 반환하기.
- **존재하는 회원의 수 만큼만 (즉, 최대로 존재하는 회원수의 만큼) 만의 배열을 만들어서 담아주
  값을 처리하여 반환 할 수 있도록 한다.** - 최소로 필요한 만큼만(단 길이는 최대로.)
- 객체 배열에 등록된 회원을 찾아서 getName 해오기. 
  ㄴ 이 과정중에 m 배열 비어있지 않은 경우에만 찾기
```java
int index=0           서치드 객체 배열에 등록되면서 증가 시킬때 인덱스에 1씩 증가시켜서 오류방지.

for{
	if(m[i]!= null){
		if(m[i].getName.equals(name)){
		searched[index++] = m[i];
		}
	}

}
return searched; 결과 객체를 담고 있는 객체배열의 주소값을 반환. 

```
### 수정하기() 메서드(View 단 )
- 메뉴번호를 사용자에게 입력받고, 스위치 케이스 문으로 메뉴 선정하기.
  단, 케이스에는 각각의 메서드 호출한다.
- id가 중복이 불가능하고,id는 회원이 있는지 없는지에 대한 __식별자__ 이기 때문에 비밀번호를 변경하더라도 가져가야 하는 값임
- 비밀번호 수정print문 
- boolean result = mc.updatePasswprd(id,pw)
- if문 사용하여 수정 성공메시지와, 존재하지 않는 아이디 구분하기.
### updatePassword() (컨트롤러)
- id 비교해서 일치하는 회원정보가 있으면 해당 회원의 비번 변경
- for문으로 m 배열 돌리고 if로 !null로 비교하고,  getid로 찾은다음,, set password 작성 
- 리턴값으로 true 싣고 보내도 작동 됨.
- else 에는 false 실어주기.


## 현 코드의 문제점. 
메소드를 호출 할 때마다 객체배열이 정렬되어 들어가지 않았음, 그래서 for문 안에서 배열의 길이만큼 null을 만날때까지 혹은 만나지 않을때까지 계속 돌려줬었는데 효율성이 떨어짐.
메소드는 호출 될 때마다 돌아가고
==만약 for문안에 메소드가 있다면 for문이 끝날때까지 리소스를 사용한다.== 
불필요한 반복을 줄여서 리소스 절약 ( 최적화 되게끔.)
그래서 불필요한 코드를 줄이고, 데이터를 정렬하는 알고리즘이 필요한것이다.
- 코드의 변경을 통하여 객체배열에서 인덱스의 값 0 부터 순차적으로 데이터가 채워지고 / 데이터가 삭제 될 시에 앞으로 땅겨준다고 가정 했을때, exsistNum() 메소드를 통해서 현재 회원의 수(== 즉 현재 비어있는 인덱스 번호)를 파악 할 수 있음.

등록된 인원수 만큼 반복하기
전달 받은 아이디와 일치하는 아이디를 갖는 객체의 위치 찾기
해당 객체가 담긴 인덱스 위치에 null을 넣어야 한다 그리고 뒤에 있는 객체들을 한칸씩 앞으로 댕겨야 함.


## 정렬 알고리즘 소스코드 

```java
for(int i = 0;i<existNum;i++)
	{
		if (m[i].getId().eqals(id)) {
			// 해당 객체가 담긴 인덱스 위치에 null을 넣어야 한다 그리고 뒤에 있는 객체들을 한칸씩 앞으로 댕겨주는 작업 처리를 해야함
			// 해당 위치 뒤에 객체들이 있다면 해당 위치에 null을 넣어주는 대신 뒤에있는 객체들은 한칸씩 땡겨오고 마지막 위치에 null을 넣어준다
			// 만약 마지막 위치에서 찾으면 그냥 null 대입하기
			if (i == (existNum - 1)) {
				m[i] = null;
			} else {
				// 마지막이 아니라면 ? 뒤에 있는 객체들이 있다면 앞으로 땡겨주기
				// 뒤에놈 앞에다 덮어씌우기.
				for (int j = i; j < exsistNum - 1; j++) { // 마지막 인덱스 벗어나면 안되니까. -1 처리
					// 뒤에 있는 대상 앞으로 댕기기
					m[j] = m[j + 1];
				}
				// 마지막 대상에 null 대입.
				m[existNum - 1] = null;
			}

		}

	}
```